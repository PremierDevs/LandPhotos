<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphics Manipulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .app-container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1rem;
            max-width: 1400px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        @media (min-width: 1024px) {
            .app-container {
                flex-direction: row;
                height: 90vh;
                align-items: stretch;
            }
        }
        .sidebar {
            width: 100%;
            max-width: 320px;
            background-color: #f8fafc;
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        @media (min-width: 1024px) {
            .sidebar {
                height: auto;
            }
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
        }
        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            background-color: #f8fafc;
            width: 100%;
            max-width: 700px;
            height: auto;
            display: block;
            margin: 0 auto;
            cursor: default;
        }
        .control-group {
            background-color: #f8fafc;
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px solid #e2e8f0;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #cbd5e1;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            background: none;
            padding: 0;
            overflow: hidden;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }
        input[type="color"]::-moz-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }
        button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.15), 0 3px 6px -2px rgba(0, 0, 0, 0.08);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="app-container bg-white rounded-xl shadow-xl">
        <div class="sidebar">
            <h1 class="text-2xl font-bold text-gray-800 text-center mb-4">Image Editor Tools</h1>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Image Source</h2>
                <input type="file" id="imageUpload" accept="image/*" class="w-full text-gray-700 bg-white border border-gray-300 rounded-md py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Color Overlay (Bottom Layer)</h2>
                <div class="flex items-center gap-4 mb-3">
                    <label for="overlayColor" class="text-gray-600 font-medium">Color:</label>
                    <input type="color" id="overlayColor" value="#3b82f6" class="flex-shrink-0">
                    <span id="overlayHexValue" class="text-gray-700 font-mono text-sm">#3b82f6</span>
                </div>
                <div class="mt-4">
                    <h3 class="text-md font-medium text-gray-600 mb-2">Presets:</h3>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="overlay-preset-btn bg-black text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#000000">Black</button>
                        <button class="overlay-preset-btn bg-yellow-800 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#704214">Sepia</button>
                        <button class="overlay-preset-btn bg-gray-700 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#333333">Dark Gray</button>
                        <button class="overlay-preset-btn bg-white text-gray-800 border border-gray-300 py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#FFFFFF">White</button>
                        <button class="overlay-preset-btn bg-teal-600 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#008080">Teal</button>
                        <button class="overlay-preset-btn bg-purple-600 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#800080">Purple</button>
                    </div>
                </div>
                <div>
                    <label for="overlayOpacity" class="block text-gray-600 font-medium mb-2 mt-4">Opacity:</label>
                    <input type="range" id="overlayOpacity" min="0" max="1" step="0.01" value="0.5" class="w-full">
                    <span id="overlayOpacityValue" class="block text-right text-gray-700 text-sm mt-1">0.50</span>
                </div>
            </div>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Pen Tool (Top Layer Mask)</h2>
                <div class="flex flex-col sm:flex-row gap-3">
                    <button id="activatePenTool" class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-600 active:bg-blue-700">Activate Pen Tool</button>
                    <button id="clearMask" class="flex-1 bg-red-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-red-600 active:bg-red-700">Clear Mask</button>
                </div>
                <p class="text-sm text-gray-500 mt-3">Click on the canvas to draw points. Click the first point to close the path.</p>
            </div>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Drop Shadow (Top Layer)</h2>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <div class="flex items-center gap-2">
                        <label for="shadowColor" class="text-gray-600 font-medium">Color:</label>
                        <input type="color" id="shadowColor" value="#000000" class="flex-shrink-0">
                        <span id="shadowHexValue" class="text-gray-700 font-mono text-sm">#000000</span>
                    </div>
                    <div>
                        <label for="shadowOpacity" class="block text-gray-600 font-medium mb-1">Opacity:</label>
                        <input type="range" id="shadowOpacity" min="0" max="1" step="0.01" value="0.75" class="w-full">
                        <span id="shadowOpacityValue" class="block text-right text-gray-700 text-sm mt-1">0.75</span>
                    </div>
                    <div>
                        <label for="shadowBlur" class="block text-gray-600 font-medium mb-1">Blur:</label>
                        <input type="range" id="shadowBlur" min="0" max="150" step="1" value="10" class="w-full">
                        <span id="shadowBlurValue" class="block text-right text-gray-700 text-sm mt-1">10px</span>
                    </div>
                    <div>
                        <label for="shadowDistance" class="block text-gray-600 font-medium mb-1">Distance:</label>
                        <input type="range" id="shadowDistance" min="0" max="150" step="1" value="5" class="w-full">
                        <span id="shadowDistanceValue" class="block text-right text-gray-700 text-sm mt-1">5px</span>
                    </div>
                    <div class="sm:col-span-2">
                        <label for="shadowAngle" class="block text-gray-600 font-medium mb-1">Angle:</label>
                        <input type="range" id="shadowAngle" min="0" max="360" step="1" value="45" class="w-full">
                        <span id="shadowAngleValue" class="block text-right text-gray-700 text-sm mt-1">45°</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Masked Layer Outline</h2>
                <div class="flex items-center gap-2 mb-3">
                    <input type="checkbox" id="enableOutline" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <label for="enableOutline" class="text-gray-600 font-medium">Enable Outline</label>
                </div>
                <div class="flex items-center gap-4 mb-3">
                    <label for="outlineColor" class="text-gray-600 font-medium">Color:</label>
                    <input type="color" id="outlineColor" value="#ffffff" class="flex-shrink-0">
                    <span id="outlineHexValue" class="text-gray-700 font-mono text-sm">#ffffff</span>
                </div>
                <div>
                    <label for="outlineWidth" class="block text-gray-600 font-medium mb-2">Width:</label>
                    <input type="range" id="outlineWidth" min="0" max="100" step="1" value="2" class="w-full">
                    <span id="outlineWidthValue" class="block text-right text-gray-700 text-sm mt-1">2px</span>
                </div>
            </div>
            
            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Zoom & Crop</h2>
                <div>
                    <label for="zoomSlider" class="block text-gray-600 font-medium mb-1">Zoom:</label>
                    <input type="range" id="zoomSlider" min="1" max="3" step="0.01" value="1" class="w-full">
                    <span id="zoomValue" class="block text-right text-gray-700 text-sm mt-1">100%</span>
                </div>
                <p class="text-sm text-gray-500 mt-3">When zoomed in, click and drag the image to pan.</p>
                <div class="flex flex-col sm:flex-row gap-3 mt-4">
                    <button id="applyCrop" class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-600 active:bg-blue-700">Apply Crop</button>
                    <button id="resetView" class="flex-1 bg-gray-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-gray-600 active:bg-gray-700">Reset View</button>
                </div>
            </div>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Disclaimer Text</h2>
                <div class="flex flex-col gap-3">
                    <button id="toggleDisclaimer" class="w-full bg-blue-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-600 active:bg-blue-700">Add Disclaimer</button>
                </div>
                <div id="disclaimerControls" class="hidden mt-4 space-y-4">
                    <div>
                        <label for="disclaimerFontSize" class="block text-gray-600 font-medium mb-1">Font Size:</label>
                        <input type="range" id="disclaimerFontSize" min="12" max="72" step="1" value="24" class="w-full">
                        <span id="disclaimerFontSizeValue" class="block text-right text-gray-700 text-sm mt-1">24px</span>
                    </div>
                    <div class="flex items-center gap-4">
                        <label for="disclaimerColor" class="text-gray-600 font-medium">Color:</label>
                        <input type="color" id="disclaimerColor" value="#FFFFFF">
                        <span id="disclaimerHexValue" class="text-gray-700 font-mono text-sm">#FFFFFF</span>
                    </div>
                </div>
            </div>

            <div class="flex flex-col gap-3 mt-4">
                <button id="saveAsJpg" class="bg-green-500 text-white py-3 px-6 rounded-lg font-semibold hover:bg-green-600 active:bg-green-700 w-full">Save as JPG</button>
                <button id="resetAll" class="bg-gray-200 text-gray-800 py-3 px-6 rounded-lg font-semibold hover:bg-gray-300 active:bg-gray-400 w-full">Reset All</button>
            </div>
        </div>

        <div class="main-content">
            <canvas id="imageCanvas"></canvas>
            <div id="messageBox" class="mt-4 p-3 bg-blue-100 text-blue-800 rounded-md hidden"></div>
        </div>
    </div>

<script>
    // --- DOM Element References ---
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const messageBox = document.getElementById('messageBox');
    const imageUpload = document.getElementById('imageUpload');
    const overlayColorInput = document.getElementById('overlayColor');
    const overlayHexValueSpan = document.getElementById('overlayHexValue');
    const overlayOpacityInput = document.getElementById('overlayOpacity');
    const overlayOpacityValueSpan = document.getElementById('overlayOpacityValue');
    const overlayPresetBtns = document.querySelectorAll('.overlay-preset-btn');
    const activatePenToolBtn = document.getElementById('activatePenTool');
    const clearMaskBtn = document.getElementById('clearMask');
    const shadowColorInput = document.getElementById('shadowColor');
    const shadowHexValueSpan = document.getElementById('shadowHexValue');
    const shadowOpacityInput = document.getElementById('shadowOpacity');
    const shadowOpacityValueSpan = document.getElementById('shadowOpacityValue');
    const shadowBlurInput = document.getElementById('shadowBlur');
    const shadowBlurValueSpan = document.getElementById('shadowBlurValue');
    const shadowDistanceInput = document.getElementById('shadowDistance');
    const shadowDistanceValueSpan = document.getElementById('shadowDistanceValue');
    const shadowAngleInput = document.getElementById('shadowAngle');
    const shadowAngleValueSpan = document.getElementById('shadowAngleValue');
    const enableOutlineInput = document.getElementById('enableOutline');
    const outlineColorInput = document.getElementById('outlineColor');
    const outlineHexValueSpan = document.getElementById('outlineHexValue');
    const outlineWidthInput = document.getElementById('outlineWidth');
    const outlineWidthValueSpan = document.getElementById('outlineWidthValue');
    const saveAsJpgBtn = document.getElementById('saveAsJpg');
    const resetAllBtn = document.getElementById('resetAll');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValueSpan = document.getElementById('zoomValue');
    const applyCropBtn = document.getElementById('applyCrop');
    const resetViewBtn = document.getElementById('resetView');
    const toggleDisclaimerBtn = document.getElementById('toggleDisclaimer');
    const disclaimerControls = document.getElementById('disclaimerControls');
    const disclaimerFontSizeSlider = document.getElementById('disclaimerFontSize');
    const disclaimerFontSizeValue = document.getElementById('disclaimerFontSizeValue');
    const disclaimerColorInput = document.getElementById('disclaimerColor');
    const disclaimerHexValue = document.getElementById('disclaimerHexValue');

    // --- State Variables ---
    let originalImage = new Image();
    let isImageLoaded = false;
    let isPenToolActive = false;
    let zoomLevel = 1.0;
    let panOffset = { x: 0, y: 0 };
    let isPanning = false;
    let startPanPoint = { x: 0, y: 0 };
    
    // Pen Tool State
    let maskPath = null;
    let drawingPoints = [];
    let maskPoints = [];
    let isDrawing = false;
    let isDraggingNode = false;
    let draggedNodeIndex = -1;

    // Disclaimer State
    const disclaimerText = `Boundary lines are simply for perspective.\n
    Buyers are encouraged to consult property survey.`;
    let isDisclaimerVisible = false;
    let isDraggingDisclaimer = false;
    let disclaimerDragOffset = { x: 0, y: 0 };
    let disclaimerProps = { x: 0, y: 0, fontSize: 24, color: '#FFFFFF', lineHeight: 28, maxWidthPercentage: 0.9 };
    
    // Constants and Defaults
    const defaultOverlayColor = '#3b82f6';
    const defaultOverlayOpacity = 0.5;
    const defaultShadowColor = '#000000';
    const defaultShadowOpacity = 0.75;
    const defaultShadowBlur = 10;
    const defaultShadowDistance = 5;
    const defaultShadowAngle = 45;
    const defaultEnableOutline = false;
    const defaultOutlineColor = '#ffffff';
    const defaultOutlineWidth = 2;
    const defaultImageUrl = 'https://placehold.co/700x500/A0B0C0/FFFFFF?text=Upload+Image';
    const BASE_PEN_LINE_WIDTH = 3;
    const BASE_PEN_POINT_RADIUS = 6;
    const BASE_PEN_FIRST_POINT_RADIUS = 8;
    const BASE_PEN_CLOSE_THRESHOLD = 12;

    // --- Helper Functions ---
    function hexToRgba(hex, alpha) {
        let r = 0, g = 0, b = 0;
        if (hex.length === 4) { r = parseInt(hex[1] + hex[1], 16); g = parseInt(hex[2] + hex[2], 16); b = parseInt(hex[3] + hex[3], 16); } 
        else if (hex.length === 7) { r = parseInt(hex.substring(1, 3), 16); g = parseInt(hex.substring(3, 5), 16); b = parseInt(hex.substring(5, 7), 16); }
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function getPenToolScale() {
        if (!isImageLoaded || !canvas.width) { return 1; }
        return canvas.width / 700;
    }

    function getMousePos(canvasEl, event) {
        const rect = canvasEl.getBoundingClientRect();
        const mouseX = (event.clientX - rect.left) * (canvasEl.width / rect.width);
        const mouseY = (event.clientY - rect.top) * (canvasEl.height / rect.height);
        return {
            x: mouseX, y: mouseY,
            tx: (mouseX - panOffset.x) / zoomLevel,
            ty: (mouseY - panOffset.y) / zoomLevel,
        };
    }
    
    function getDisclaimerLines(context) {
        const scaledFontSize = disclaimerProps.fontSize * (canvas.width / 700);
        context.font = `bold ${scaledFontSize}px Inter`;
        const maxWidth = canvas.width * disclaimerProps.maxWidthPercentage;
        const words = disclaimerText.split(' ');
        let lines = [];
        let currentLine = words[0];
        for (let i = 1; i < words.length; i++) {
            let word = words[i];
            let width = context.measureText(currentLine + " " + word).width;
            if (width < maxWidth) { currentLine += " " + word; } 
            else { lines.push(currentLine); currentLine = word; }
        }
        lines.push(currentLine);
        return lines;
    }

    function getDisclaimerBounds(context) {
        if (!isDisclaimerVisible || !isImageLoaded) return null;
        const lines = getDisclaimerLines(context);
        const scaledLineHeight = (disclaimerProps.fontSize * 1.2) * (canvas.width / 700);
        const totalHeight = lines.length * scaledLineHeight;
        const totalWidth = Math.max(...lines.map(line => context.measureText(line).width));
        return {
            x: disclaimerProps.x - totalWidth / 2,
            y: disclaimerProps.y - scaledLineHeight,
            width: totalWidth,
            height: totalHeight
        };
    }
    
    function drawDisclaimer(context) {
        if (!isDisclaimerVisible) return;
        const scaledFontSize = disclaimerProps.fontSize * (canvas.width / 700);
        const scaledLineHeight = (disclaimerProps.fontSize * 1.2) * (canvas.width / 700);
        context.font = `bold ${scaledFontSize}px Inter`;
        context.fillStyle = disclaimerProps.color;
        context.textAlign = 'center';
        const lines = getDisclaimerLines(context);
        let y = disclaimerProps.y;
        for (const line of lines) {
            context.fillText(line, disclaimerProps.x, y);
            y += scaledLineHeight;
        }
    }

    function updateMaskFromPoints() {
        if (maskPoints.length < 2) {
            maskPath = null;
            return;
        }
        const path = new Path2D();
        path.moveTo(maskPoints[0].x, maskPoints[0].y);
        for (let i = 1; i < maskPoints.length; i++) { path.lineTo(maskPoints[i].x, maskPoints[i].y); }
        path.closePath();
        maskPath = path;
    }

    // --- Core Functions ---
    function initializeControls() {
        // ... all control resets
        overlayColorInput.value = defaultOverlayColor;
        overlayHexValueSpan.textContent = defaultOverlayColor;
        overlayOpacityInput.value = defaultOverlayOpacity;
        overlayOpacityValueSpan.textContent = defaultOverlayOpacity.toFixed(2);
        shadowColorInput.value = defaultShadowColor;
        shadowHexValueSpan.textContent = defaultShadowColor;
        shadowOpacityInput.value = defaultShadowOpacity;
        shadowOpacityValueSpan.textContent = defaultShadowOpacity.toFixed(2);
        shadowBlurInput.value = defaultShadowBlur;
        shadowBlurValueSpan.textContent = `${defaultShadowBlur}px`;
        shadowDistanceInput.value = defaultShadowDistance;
        shadowDistanceValueSpan.textContent = `${defaultShadowDistance}px`;
        shadowAngleInput.value = defaultShadowAngle;
        shadowAngleValueSpan.textContent = `${defaultShadowAngle}°`;
        enableOutlineInput.checked = defaultEnableOutline;
        outlineColorInput.value = defaultOutlineColor;
        outlineHexValueSpan.textContent = defaultOutlineColor;
        outlineWidthInput.value = defaultOutlineWidth;
        outlineWidthValueSpan.textContent = `${defaultOutlineWidth}px`;
        
        zoomSlider.value = 1.0;
        zoomValueSpan.textContent = '100%';
        zoomLevel = 1.0;
        panOffset = { x: 0, y: 0 };

        isDisclaimerVisible = false;
        disclaimerControls.classList.add('hidden');
        toggleDisclaimerBtn.textContent = 'Add Disclaimer';
        toggleDisclaimerBtn.classList.replace('bg-red-500', 'bg-blue-500');
        disclaimerFontSizeSlider.value = 24;
        disclaimerFontSizeValue.textContent = '24px';
        disclaimerColorInput.value = '#FFFFFF';
        disclaimerHexValue.textContent = '#FFFFFF';
        disclaimerProps.fontSize = 24;
        disclaimerProps.lineHeight = 28;
        disclaimerProps.color = '#FFFFFF';
    }

    function showMessage(message, type = 'info') {
        messageBox.textContent = message;
        messageBox.classList.remove('hidden', 'bg-blue-100', 'text-blue-800', 'bg-red-100', 'text-red-800', 'bg-green-100', 'text-green-800');
        if (type === 'info') { messageBox.classList.add('bg-blue-100', 'text-blue-800'); } 
        else if (type === 'error') { messageBox.classList.add('bg-red-100', 'text-red-800'); } 
        else if (type === 'success') { messageBox.classList.add('bg-green-100', 'text-green-800'); }
        setTimeout(() => { messageBox.classList.add('hidden'); }, 3000);
    }
    
    function loadImage(src) {
        originalImage.onload = () => {
            isImageLoaded = true;
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            initializeControls();
            draw();
            showMessage('Image loaded successfully!', 'success');
        };
        originalImage.onerror = () => {
            isImageLoaded = false;
            showMessage('Failed to load image. Please try another one.', 'error');
            originalImage.src = defaultImageUrl;
        };
        originalImage.src = src;
    }

    function draw() {
        if (!isImageLoaded) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#666';
            ctx.font = '20px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Upload an image to start', canvas.width / 2, canvas.height / 2);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(panOffset.x, panOffset.y);
        ctx.scale(zoomLevel, zoomLevel);

        ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
        ctx.fillStyle = overlayColorInput.value;
        ctx.globalAlpha = parseFloat(overlayOpacityInput.value);
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1.0;

        if (maskPath) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.save();
            tempCtx.clip(maskPath);
            tempCtx.drawImage(originalImage, 0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.restore();
            ctx.save();
            const sd = parseInt(shadowDistanceInput.value), sa = (parseInt(shadowAngleInput.value) - 180) * Math.PI / 180;
            ctx.shadowColor = hexToRgba(shadowColorInput.value, parseFloat(shadowOpacityInput.value));
            ctx.shadowBlur = parseInt(shadowBlurInput.value);
            ctx.shadowOffsetX = sd * Math.cos(sa);
            ctx.shadowOffsetY = sd * Math.sin(sa);
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();
            if (enableOutlineInput.checked) {
                ctx.save();
                ctx.strokeStyle = outlineColorInput.value;
                ctx.lineWidth = parseInt(outlineWidthInput.value);
                ctx.stroke(maskPath);
                ctx.restore();
            }
        }

        // 3. Pen Tool Guides (for drawing or editing)
        // ✨ BUG FIX: Define scale once, outside the if-statements.
        const scale = getPenToolScale();
        
        if (isDrawing && drawingPoints.length > 0) {
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = BASE_PEN_LINE_WIDTH * scale;
            ctx.beginPath();
            ctx.moveTo(drawingPoints[0].x, drawingPoints[0].y);
            for (let i = 1; i < drawingPoints.length; i++) { ctx.lineTo(drawingPoints[i].x, drawingPoints[i].y); }
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            drawingPoints.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, BASE_PEN_POINT_RADIUS * scale, 0, Math.PI * 2); ctx.fill(); });
            if (drawingPoints.length > 0) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(drawingPoints[0].x, drawingPoints[0].y, BASE_PEN_FIRST_POINT_RADIUS * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        if (isPenToolActive && maskPoints.length > 0) {
            ctx.strokeStyle = 'rgba(0, 100, 255, 0.7)';
            ctx.lineWidth = (BASE_PEN_LINE_WIDTH - 1) * scale;
            ctx.beginPath();
            ctx.moveTo(maskPoints[0].x, maskPoints[0].y);
            for (let i = 1; i < maskPoints.length; i++) { ctx.lineTo(maskPoints[i].x, maskPoints[i].y); }
            ctx.closePath();
            ctx.stroke();
            ctx.fillStyle = 'rgba(0, 100, 255, 0.8)';
            maskPoints.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, BASE_PEN_POINT_RADIUS * scale, 0, Math.PI * 2); ctx.fill(); });
        }
        
        drawDisclaimer(ctx);
        ctx.restore();
    }

    // --- Event Listeners ---
    imageUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) { const reader = new FileReader(); reader.onload = (event) => loadImage(event.target.result); reader.readAsDataURL(file); }
    });
    
    overlayColorInput.addEventListener('input', () => { overlayHexValueSpan.textContent = overlayColorInput.value; draw(); });
    overlayOpacityInput.addEventListener('input', () => { overlayOpacityValueSpan.textContent = parseFloat(overlayOpacityInput.value).toFixed(2); draw(); });
    overlayPresetBtns.forEach(button => { button.addEventListener('click', () => { const color = button.dataset.color; overlayColorInput.value = color; overlayHexValueSpan.textContent = color; draw(); }); });
    shadowColorInput.addEventListener('input', () => { shadowHexValueSpan.textContent = shadowColorInput.value; draw(); });
    shadowOpacityInput.addEventListener('input', () => { shadowOpacityValueSpan.textContent = parseFloat(shadowOpacityInput.value).toFixed(2); draw(); });
    shadowBlurInput.addEventListener('input', () => { shadowBlurValueSpan.textContent = `${shadowBlurInput.value}px`; draw(); });
    shadowDistanceInput.addEventListener('input', () => { shadowDistanceValueSpan.textContent = `${shadowDistanceInput.value}px`; draw(); });
    shadowAngleInput.addEventListener('input', () => { shadowAngleValueSpan.textContent = `${shadowAngleInput.value}°`; draw(); });
    
    activatePenToolBtn.addEventListener('click', () => {
        isPenToolActive = !isPenToolActive;
        if (isPenToolActive) {
            activatePenToolBtn.textContent = 'Deactivate Pen Tool';
            activatePenToolBtn.classList.replace('bg-blue-500', 'bg-orange-500');
            showMessage('Pen tool activated.', 'info');
            canvas.style.cursor = 'crosshair';
        } else {
            activatePenToolBtn.textContent = 'Activate Pen Tool';
            activatePenToolBtn.classList.replace('bg-orange-500', 'bg-blue-500');
            isDrawing = false;
            showMessage('Pen tool deactivated.', 'info');
            canvas.style.cursor = 'default';
        }
        draw();
    });

    // ✨ BUG FIX: Single, correct event listener for clearMaskBtn
    clearMaskBtn.addEventListener('click', () => {
        drawingPoints = [];
        maskPoints = [];
        maskPath = null;
        isDrawing = false;
        showMessage('Mask cleared!', 'success');
        draw();
    });

    enableOutlineInput.addEventListener('change', draw);
    outlineColorInput.addEventListener('input', () => { outlineHexValueSpan.textContent = outlineColorInput.value; draw(); });
    outlineWidthInput.addEventListener('input', () => { outlineWidthValueSpan.textContent = `${outlineWidthInput.value}px`; draw(); });
    zoomSlider.addEventListener('input', (e) => {
        zoomLevel = parseFloat(e.target.value);
        zoomValueSpan.textContent = `${Math.round(zoomLevel * 100)}%`;
        if (zoomLevel === 1) { panOffset = { x: 0, y: 0 }; }
        canvas.style.cursor = zoomLevel > 1 ? 'grab' : 'default';
        draw();
    });
    resetViewBtn.addEventListener('click', () => { initializeControls(); draw(); });
    applyCropBtn.addEventListener('click', () => {
        if (!isImageLoaded) return;
        const sX = -panOffset.x, sY = -panOffset.y, sW = canvas.width / zoomLevel, sH = canvas.height / zoomLevel;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = sW; tempCanvas.height = sH;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(originalImage, sX, sY, sW, sH, 0, 0, sW, sH);
        clearMaskBtn.click();
        loadImage(tempCanvas.toDataURL());
        showMessage('Crop applied!', 'success');
    });
    saveAsJpgBtn.addEventListener('click', () => {
        if (!isImageLoaded) { showMessage('Please upload an image first!', 'error'); return; }
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/jpeg', 0.9);
        link.download = 'graphics_manipulated.jpg';
        link.click();
        showMessage('Image saved as JPG!', 'success');
    });
    toggleDisclaimerBtn.addEventListener('click', () => {
        isDisclaimerVisible = !isDisclaimerVisible;
        if (isDisclaimerVisible) {
            disclaimerControls.classList.remove('hidden');
            toggleDisclaimerBtn.textContent = 'Remove Disclaimer';
            toggleDisclaimerBtn.classList.replace('bg-blue-500', 'bg-red-500');
            disclaimerProps.x = canvas.width / 2;
            disclaimerProps.y = canvas.height - (disclaimerProps.lineHeight * 3 * (canvas.width / 700));
        } else {
            disclaimerControls.classList.add('hidden');
            toggleDisclaimerBtn.textContent = 'Add Disclaimer';
            toggleDisclaimerBtn.classList.replace('bg-red-500', 'bg-blue-500');
        }
        draw();
    });
    disclaimerFontSizeSlider.addEventListener('input', (e) => {
        const size = parseInt(e.target.value, 10);
        disclaimerProps.fontSize = size;
        disclaimerFontSizeValue.textContent = `${size}px`;
        draw();
    });
    disclaimerColorInput.addEventListener('input', (e) => {
        disclaimerProps.color = e.target.value;
        disclaimerHexValue.textContent = e.target.value;
        draw();
    });

    canvas.addEventListener('mousedown', (e) => {
        const pos = getMousePos(canvas, e);
        const bounds = getDisclaimerBounds(ctx);
        if (bounds && pos.tx > bounds.x && pos.tx < bounds.x + bounds.width && pos.ty > bounds.y && pos.ty < bounds.y + bounds.height) {
            isDraggingDisclaimer = true; canvas.style.cursor = 'move';
            disclaimerDragOffset.x = pos.tx - disclaimerProps.x; disclaimerDragOffset.y = pos.ty - disclaimerProps.y;
            return;
        }
        if (isPenToolActive) {
            const nodeRadius = BASE_PEN_POINT_RADIUS * getPenToolScale();
            for (let i = 0; i < maskPoints.length; i++) {
                const node = maskPoints[i];
                const distance = Math.sqrt(Math.pow(pos.tx - node.x, 2) + Math.pow(pos.ty - node.y, 2));
                if (distance < nodeRadius) {
                    isDraggingNode = true; draggedNodeIndex = i; canvas.style.cursor = 'grabbing';
                    return;
                }
            }
        }
        if (zoomLevel > 1 && !isPenToolActive) {
            isPanning = true; startPanPoint = { x: pos.x - panOffset.x, y: pos.y - panOffset.y }; canvas.style.cursor = 'grabbing';
            return;
        }
        if (isPenToolActive) {
            if (!isDrawing) { maskPoints = []; maskPath = null; drawingPoints = []; }
            isDrawing = true;
            if (drawingPoints.length > 0) {
                const firstPoint = drawingPoints[0];
                const distance = Math.sqrt(Math.pow(pos.tx - firstPoint.x, 2) + Math.pow(pos.ty - firstPoint.y, 2));
                const closeThreshold = BASE_PEN_CLOSE_THRESHOLD * getPenToolScale();
                if (distance < closeThreshold) {
                    isDrawing = false; maskPoints = [...drawingPoints]; drawingPoints = []; updateMaskFromPoints();
                    showMessage('Mask applied!', 'success');
                } else { drawingPoints.push({ x: pos.tx, y: pos.ty }); }
            } else { drawingPoints.push({ x: pos.tx, y: pos.ty }); }
        }
        draw();
    });

    canvas.addEventListener('mousemove', (e) => {
        const pos = getMousePos(canvas, e);
        if (isDraggingDisclaimer) {
            disclaimerProps.x = pos.tx - disclaimerDragOffset.x; disclaimerProps.y = pos.ty - disclaimerDragOffset.y;
            draw(); return;
        }
        if (isDraggingNode) {
            maskPoints[draggedNodeIndex].x = pos.tx; maskPoints[draggedNodeIndex].y = pos.ty;
            updateMaskFromPoints(); draw(); return;
        }
        if (isPanning) {
            panOffset.x = pos.x - startPanPoint.x; panOffset.y = pos.y - startPanPoint.y;
            const maxPanX = (canvas.width * zoomLevel - canvas.width), maxPanY = (canvas.height * zoomLevel - canvas.height);
            panOffset.x = Math.max(-maxPanX, Math.min(0, panOffset.x)); panOffset.y = Math.max(-maxPanY, Math.min(0, panOffset.y));
            draw(); return;
        }
        if (isPenToolActive && maskPoints.length > 0) {
            const nodeRadius = BASE_PEN_POINT_RADIUS * getPenToolScale();
            let hoveringNode = false;
            for (const node of maskPoints) {
                if (Math.sqrt(Math.pow(pos.tx - node.x, 2) + Math.pow(pos.ty - node.y, 2)) < nodeRadius) { hoveringNode = true; break; }
            }
            canvas.style.cursor = hoveringNode ? 'grab' : 'crosshair';
        }
    });

    canvas.addEventListener('mouseup', () => {
        isPanning = false; isDraggingDisclaimer = false; isDraggingNode = false; draggedNodeIndex = -1;
        canvas.style.cursor = isPenToolActive ? 'crosshair' : (zoomLevel > 1 ? 'grab' : 'default');
    });
    
    canvas.addEventListener('mouseleave', () => {
        isPanning = false; isDraggingDisclaimer = false; isDraggingNode = false; draggedNodeIndex = -1;
        canvas.style.cursor = 'default';
    });
    
    resetAllBtn.addEventListener('click', () => {
        loadImage(defaultImageUrl);
        showMessage('All settings reset!', 'success');
    });

    window.addEventListener('resize', draw);
    window.onload = () => {
        initializeControls();
        loadImage(defaultImageUrl);
        canvas.style.width = '100%';
        canvas.style.height = 'auto';
    };
</script>


</body>
</html>
