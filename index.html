<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphics Manipulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top to allow for scroll if content is long */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .app-container {
            background-color: #ffffff;
            border-radius: 1rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            padding: 1rem; /* Slightly reduced padding for overall fit */
            max-width: 1400px; /* Increased max-width for sidebar */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Reduced gap */
        }
        @media (min-width: 1024px) {
            .app-container {
                flex-direction: row;
                height: 90vh; /* Fixed height for desktop layout */
                align-items: stretch; /* Stretch items to fill height */
            }
        }

        .sidebar {
            width: 100%;
            max-width: 320px; /* Max width for sidebar on desktop */
            background-color: #f8fafc; /* bg-gray-50 */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06); /* subtle inner shadow */
            overflow-y: auto; /* Enable scrolling for many panels */
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            display: flex; /* Ensure flex for internal arrangement */
            flex-direction: column; /* Stack control groups vertically */
            gap: 1.5rem; /* Spacing between control groups */
        }
        @media (min-width: 1024px) {
            .sidebar {
                height: auto; /* Auto height within flex container */
            }
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
        }

        canvas {
            border: 1px solid #e2e8f0; /* border-gray-200 */
            border-radius: 0.5rem; /* rounded-lg */
            background-color: #f8fafc; /* bg-gray-50 */
            width: 100%;
            max-width: 700px; /* Limit canvas width for better control layout */
            height: auto; /* Maintain aspect ratio */
            display: block;
            margin: 0 auto; /* Center canvas */
            cursor: default;
        }
        
        .control-group {
            background-color: #f8fafc; /* bg-gray-50 */
            padding: 1rem;
            border-radius: 0.75rem; /* rounded-lg */
            border: 1px solid #e2e8f0; /* border-gray-200 */
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #cbd5e1; /* bg-gray-300 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            background: none;
            padding: 0;
            overflow: hidden;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }
        input[type="color"]::-moz-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }
        button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.15), 0 3px 6px -2px rgba(0, 0, 0, 0.08);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="app-container bg-white rounded-xl shadow-xl">
        <div class="sidebar">
            <h1 class="text-2xl font-bold text-gray-800 text-center mb-4">Image Editor Tools</h1>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Image Source</h2>
                <input type="file" id="imageUpload" accept="image/*" class="w-full text-gray-700 bg-white border border-gray-300 rounded-md py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Color Overlay (Bottom Layer)</h2>
                <div class="flex items-center gap-4 mb-3">
                    <label for="overlayColor" class="text-gray-600 font-medium">Color:</label>
                    <input type="color" id="overlayColor" value="#3b82f6" class="flex-shrink-0">
                    <span id="overlayHexValue" class="text-gray-700 font-mono text-sm">#3b82f6</span>
                </div>
                <div class="mt-4">
                    <h3 class="text-md font-medium text-gray-600 mb-2">Presets:</h3>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="overlay-preset-btn bg-black text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#000000">Black</button>
                        <button class="overlay-preset-btn bg-yellow-800 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#704214">Sepia</button>
                        <button class="overlay-preset-btn bg-gray-700 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#333333">Dark Gray</button>
                        <button class="overlay-preset-btn bg-white text-gray-800 border border-gray-300 py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#FFFFFF">White</button>
                        <button class="overlay-preset-btn bg-teal-600 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#008080">Teal</button>
                        <button class="overlay-preset-btn bg-purple-600 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#800080">Purple</button>
                    </div>
                </div>
                <div>
                    <label for="overlayOpacity" class="block text-gray-600 font-medium mb-2 mt-4">Opacity:</label>
                    <input type="range" id="overlayOpacity" min="0" max="1" step="0.01" value="0.5" class="w-full">
                    <span id="overlayOpacityValue" class="block text-right text-gray-700 text-sm mt-1">0.50</span>
                </div>
            </div>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Pen Tool (Top Layer Mask)</h2>
                <div class="flex flex-col sm:flex-row gap-3">
                    <button id="activatePenTool" class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-600 active:bg-blue-700">Activate Pen Tool</button>
                    <button id="clearMask" class="flex-1 bg-red-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-red-600 active:bg-red-700">Clear Mask</button>
                </div>
                <p class="text-sm text-gray-500 mt-3">Click on the canvas to draw points. Click the first point to close the path.</p>
            </div>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Drop Shadow (Top Layer)</h2>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <div class="flex items-center gap-2">
                        <label for="shadowColor" class="text-gray-600 font-medium">Color:</label>
                        <input type="color" id="shadowColor" value="#000000" class="flex-shrink-0">
                        <span id="shadowHexValue" class="text-gray-700 font-mono text-sm">#000000</span>
                    </div>
                    <div>
                        <label for="shadowOpacity" class="block text-gray-600 font-medium mb-1">Opacity:</label>
                        <input type="range" id="shadowOpacity" min="0" max="1" step="0.01" value="0.75" class="w-full">
                        <span id="shadowOpacityValue" class="block text-right text-gray-700 text-sm mt-1">0.75</span>
                    </div>
                    <div>
                        <label for="shadowBlur" class="block text-gray-600 font-medium mb-1">Blur:</label>
                        <input type="range" id="shadowBlur" min="0" max="150" step="1" value="10" class="w-full">
                        <span id="shadowBlurValue" class="block text-right text-gray-700 text-sm mt-1">10px</span>
                    </div>
                    <div>
                        <label for="shadowDistance" class="block text-gray-600 font-medium mb-1">Distance:</label>
                        <input type="range" id="shadowDistance" min="0" max="150" step="1" value="5" class="w-full">
                        <span id="shadowDistanceValue" class="block text-right text-gray-700 text-sm mt-1">5px</span>
                    </div>
                    <div class="sm:col-span-2"> <label for="shadowAngle" class="block text-gray-600 font-medium mb-1">Angle:</label>
                        <input type="range" id="shadowAngle" min="0" max="360" step="1" value="45" class="w-full">
                        <span id="shadowAngleValue" class="block text-right text-gray-700 text-sm mt-1">45°</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Masked Layer Outline</h2>
                <div class="flex items-center gap-2 mb-3">
                    <input type="checkbox" id="enableOutline" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <label for="enableOutline" class="text-gray-600 font-medium">Enable Outline</label>
                </div>
                <div class="flex items-center gap-4 mb-3">
                    <label for="outlineColor" class="text-gray-600 font-medium">Color:</label>
                    <input type="color" id="outlineColor" value="#ffffff" class="flex-shrink-0">
                    <span id="outlineHexValue" class="text-gray-700 font-mono text-sm">#ffffff</span>
                </div>
                <div>
                    <label for="outlineWidth" class="block text-gray-600 font-medium mb-2">Width:</label>
                    <input type="range" id="outlineWidth" min="0" max="100" step="1" value="2" class="w-full">
                    <span id="outlineWidthValue" class="block text-right text-gray-700 text-sm mt-1">2px</span>
                </div>
            </div>
            
            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Zoom & Crop</h2>
                <div>
                    <label for="zoomSlider" class="block text-gray-600 font-medium mb-1">Zoom:</label>
                    <input type="range" id="zoomSlider" min="1" max="3" step="0.01" value="1" class="w-full">
                    <span id="zoomValue" class="block text-right text-gray-700 text-sm mt-1">100%</span>
                </div>
                <p class="text-sm text-gray-500 mt-3">When zoomed in, click and drag the image to pan.</p>
                <div class="flex flex-col sm:flex-row gap-3 mt-4">
                    <button id="applyCrop" class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-600 active:bg-blue-700">Apply Crop</button>
                    <button id="resetView" class="flex-1 bg-gray-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-gray-600 active:bg-gray-700">Reset View</button>
                </div>
            </div>
            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Disclaimer Text</h2>
                <div class="flex flex-col gap-3">
                    <button id="toggleDisclaimer" class="w-full bg-blue-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-600 active:bg-blue-700">Add Disclaimer</button>
                </div>
                <div id="disclaimerControls" class="hidden mt-4 space-y-4">
                    <div>
                        <label for="disclaimerFontSize" class="block text-gray-600 font-medium mb-1">Font Size:</label>
                        <input type="range" id="disclaimerFontSize" min="12" max="72" step="1" value="24" class="w-full">
                        <span id="disclaimerFontSizeValue" class="block text-right text-gray-700 text-sm mt-1">24px</span>
                    </div>
                    <div class="flex items-center gap-4">
                        <label for="disclaimerColor" class="text-gray-600 font-medium">Color:</label>
                        <input type="color" id="disclaimerColor" value="#FFFFFF">
                        <span id="disclaimerHexValue" class="text-gray-700 font-mono text-sm">#FFFFFF</span>
                    </div>
                </div>
            </div>
            <div class="flex flex-col gap-3 mt-4">
                <button id="saveAsJpg" class="bg-green-500 text-white py-3 px-6 rounded-lg font-semibold hover:bg-green-600 active:bg-green-700 w-full">Save as JPG</button>
                <button id="resetAll" class="bg-gray-200 text-gray-800 py-3 px-6 rounded-lg font-semibold hover:bg-gray-300 active:bg-gray-400 w-full">Reset All</button>
            </div>
        </div>

        <div class="main-content">
            <canvas id="imageCanvas"></canvas>
            <div id="messageBox" class="mt-4 p-3 bg-blue-100 text-blue-800 rounded-md hidden"></div>
        </div>
    </div>

<script>
    // --- DOM Element References ---
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const messageBox = document.getElementById('messageBox');
    const imageUpload = document.getElementById('imageUpload');
    const overlayColorInput = document.getElementById('overlayColor');
    const overlayHexValueSpan = document.getElementById('overlayHexValue');
    const overlayOpacityInput = document.getElementById('overlayOpacity');
    const overlayOpacityValueSpan = document.getElementById('overlayOpacityValue');
    const overlayPresetBtns = document.querySelectorAll('.overlay-preset-btn');
    const activatePenToolBtn = document.getElementById('activatePenTool');
    const clearMaskBtn = document.getElementById('clearMask');
    const shadowColorInput = document.getElementById('shadowColor');
    const shadowHexValueSpan = document.getElementById('shadowHexValue');
    const shadowOpacityInput = document.getElementById('shadowOpacity');
    const shadowOpacityValueSpan = document.getElementById('shadowOpacityValue');
    const shadowBlurInput = document.getElementById('shadowBlur');
    const shadowBlurValueSpan = document.getElementById('shadowBlurValue');
    const shadowDistanceInput = document.getElementById('shadowDistance');
    const shadowDistanceValueSpan = document.getElementById('shadowDistanceValue');
    const shadowAngleInput = document.getElementById('shadowAngle');
    const shadowAngleValueSpan = document.getElementById('shadowAngleValue');
    const enableOutlineInput = document.getElementById('enableOutline');
    const outlineColorInput = document.getElementById('outlineColor');
    const outlineHexValueSpan = document.getElementById('outlineHexValue');
    const outlineWidthInput = document.getElementById('outlineWidth');
    const outlineWidthValueSpan = document.getElementById('outlineWidthValue');
    const saveAsJpgBtn = document.getElementById('saveAsJpg');
    const resetAllBtn = document.getElementById('resetAll');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValueSpan = document.getElementById('zoomValue');
    const applyCropBtn = document.getElementById('applyCrop');
    const resetViewBtn = document.getElementById('resetView');


    // --- State Variables ---
    let originalImage = new Image();
    let isImageLoaded = false;
    let maskPath = null;
    let isPenToolActive = false;
    let drawingPoints = [];
    let isDrawing = false;
    
    let zoomLevel = 1.0;
    let panOffset = { x: 0, y: 0 };
    let isPanning = false;
    let startPanPoint = { x: 0, y: 0 };

    const defaultOverlayColor = '#3b82f6';
    const defaultOverlayOpacity = 0.5;
    const defaultShadowColor = '#000000';
    const defaultShadowOpacity = 0.75;
    const defaultShadowBlur = 10;
    const defaultShadowDistance = 5;
    const defaultShadowAngle = 45;
    const defaultEnableOutline = false;
    const defaultOutlineColor = '#ffffff';
    const defaultOutlineWidth = 2;
    const defaultImageUrl = 'https://placehold.co/700x500/A0B0C0/FFFFFF?text=Upload+Image';
    const BASE_PEN_LINE_WIDTH = 3;
    const BASE_PEN_POINT_RADIUS = 6;
    const BASE_PEN_FIRST_POINT_RADIUS = 8;
    const BASE_PEN_CLOSE_THRESHOLD = 12;

    const disclaimerText = "Boundary lines are simply for perspective. Buyers are encouraged to consult property survey.";
    let isDisclaimerVisible = false;
    let isDraggingDisclaimer = false;
    let disclaimerDragOffset = { x: 0, y: 0 };
    let disclaimerProps = {
        x: 0, // Will be set dynamically
        y: 0, // Will be set dynamically
        fontSize: 24,
        color: '#FFFFFF',
        lineHeight: 28,
        maxWidthPercentage: 0.9 // 90% of canvas width
    };
    
    // --- Helper Functions ---
    function hexToRgba(hex, alpha) {
        let r = 0, g = 0, b = 0;
        if (hex.length === 4) {
            r = parseInt(hex[1] + hex[1], 16);
            g = parseInt(hex[2] + hex[2], 16);
            b = parseInt(hex[3] + hex[3], 16);
        } else if (hex.length === 7) {
            r = parseInt(hex.substring(1, 3), 16);
            g = parseInt(hex.substring(3, 5), 16);
            b = parseInt(hex.substring(5, 7), 16);
        }
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    function getPenToolScale() {
        const referenceWidth = 700;
        if (!isImageLoaded || !canvas.width) {
            return 1;
        }
        return canvas.width / referenceWidth;
    }
    function getDisclaimerBounds(context) {
        if (!isDisclaimerVisible || !isImageLoaded) return null;
        
        const scaledFontSize = disclaimerProps.fontSize * (canvas.width / 700);
        const scaledLineHeight = disclaimerProps.lineHeight * (canvas.width / 700);
        context.font = `${scaledFontSize}px Inter`;
        
        const maxWidth = canvas.width * disclaimerProps.maxWidthPercentage;
        const words = disclaimerText.split(' ');
        let lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            let word = words[i];
            let width = context.measureText(currentLine + " " + word).width;
            if (width < maxWidth) {
                currentLine += " " + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);

        const totalHeight = lines.length * scaledLineHeight;
        const totalWidth = Math.max(...lines.map(line => context.measureText(line).width));
        
        return {
            x: disclaimerProps.x - totalWidth / 2, // Centered alignment
            y: disclaimerProps.y - scaledLineHeight,
            width: totalWidth,
            height: totalHeight
        };
    }
    
    // ✨ NEW: Helper function to draw the wrapped text
    function drawDisclaimer(context) {
        if (!isDisclaimerVisible) return;
        
        const bounds = getDisclaimerBounds(context);
        const scaledLineHeight = disclaimerProps.lineHeight * (canvas.width / 700);

        context.fillStyle = disclaimerProps.color;
        context.textAlign = 'center'; // Always draw centered
        
        const words = disclaimerText.split(' ');
        let line = '';
        let y = disclaimerProps.y;

        for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + ' ';
            let metrics = context.measureText(testLine);
            let testWidth = metrics.width;
            if (testWidth > bounds.width && n > 0) {
                context.fillText(line, disclaimerProps.x, y);
                line = words[n] + ' ';
                y += scaledLineHeight;
            } else {
                line = testLine;
            }
        }
        context.fillText(line, disclaimerProps.x, y);
    }
    // --- Core Functions ---
    function initializeControls() {
        overlayColorInput.value = defaultOverlayColor;
        overlayHexValueSpan.textContent = defaultOverlayColor;
        overlayOpacityInput.value = defaultOverlayOpacity;
        overlayOpacityValueSpan.textContent = defaultOverlayOpacity.toFixed(2);
        shadowColorInput.value = defaultShadowColor;
        shadowHexValueSpan.textContent = defaultShadowColor;
        shadowOpacityInput.value = defaultShadowOpacity;
        shadowOpacityValueSpan.textContent = defaultShadowOpacity.toFixed(2);
        shadowBlurInput.value = defaultShadowBlur;
        shadowBlurValueSpan.textContent = `${defaultShadowBlur}px`;
        shadowDistanceInput.value = defaultShadowDistance;
        shadowDistanceValueSpan.textContent = `${defaultShadowDistance}px`;
        shadowAngleInput.value = defaultShadowAngle;
        shadowAngleValueSpan.textContent = `${defaultShadowAngle}°`;
        enableOutlineInput.checked = defaultEnableOutline;
        outlineColorInput.value = defaultOutlineColor;
        outlineHexValueSpan.textContent = defaultOutlineColor;
        outlineWidthInput.value = defaultOutlineWidth;
        outlineWidthValueSpan.textContent = `${defaultOutlineWidth}px`;

        isDisclaimerVisible = false;
        disclaimerControls.classList.add('hidden');
        toggleDisclaimerBtn.textContent = 'Add Disclaimer';
        toggleDisclaimerBtn.classList.replace('bg-red-500', 'bg-blue-500');
        disclaimerFontSizeSlider.value = 24;
        disclaimerFontSizeValue.textContent = '24px';
        disclaimerColorInput.value = '#FFFFFF';
        disclaimerHexValue.textContent = '#FFFFFF';
        disclaimerProps.fontSize = 24;
        disclaimerProps.color = '#FFFFFF';
        
        zoomSlider.value = 1.0;
        zoomValueSpan.textContent = '100%';
        zoomLevel = 1.0;
        panOffset = { x: 0, y: 0 };
    }

    function showMessage(message, type = 'info') {
        messageBox.textContent = message;
        messageBox.classList.remove('hidden', 'bg-blue-100', 'text-blue-800', 'bg-red-100', 'text-red-800', 'bg-green-100', 'text-green-800');
        if (type === 'info') {
            messageBox.classList.add('bg-blue-100', 'text-blue-800');
        } else if (type === 'error') {
            messageBox.classList.add('bg-red-100', 'text-red-800');
        } else if (type === 'success') {
            messageBox.classList.add('bg-green-100', 'text-green-800');
        }
        setTimeout(() => {
            messageBox.classList.add('hidden');
        }, 3000);
    }
    
    function loadImage(src) {
        originalImage.onload = () => {
            isImageLoaded = true;
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            initializeControls();
            draw();
            showMessage('Image loaded successfully!', 'success');
        };
        originalImage.onerror = () => {
            isImageLoaded = false;
            showMessage('Failed to load image. Please try another one.', 'error');
            originalImage.src = defaultImageUrl;
        };
        originalImage.src = src;
    }

    function draw() {
        if (!isImageLoaded) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#666';
            ctx.font = '20px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Upload an image to start', canvas.width / 2, canvas.height / 2);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();

        ctx.translate(panOffset.x, panOffset.y);
        ctx.scale(zoomLevel, zoomLevel);

        // 1. Draw Bottom Layer with Color Overlay
        ctx.save();
        ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
        const overlayColor = overlayColorInput.value;
        const overlayOpacity = parseFloat(overlayOpacityInput.value);
        ctx.fillStyle = overlayColor;
        ctx.globalAlpha = overlayOpacity;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        // 2. Draw Top Layer with Mask and Drop Shadow
        if (maskPath) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.save();
            tempCtx.clip(maskPath);
            tempCtx.drawImage(originalImage, 0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.restore();

            ctx.save();
            const shadowDistance = parseInt(shadowDistanceInput.value);
            const shadowAngleDegrees = parseInt(shadowAngleInput.value);
            const shadowAngleRadians = (shadowAngleDegrees - 180) * Math.PI / 180;
            const shadowOpacity = parseFloat(shadowOpacityInput.value);
            ctx.shadowColor = hexToRgba(shadowColorInput.value, shadowOpacity);
            ctx.shadowBlur = parseInt(shadowBlurInput.value);
            ctx.shadowOffsetX = shadowDistance * Math.cos(shadowAngleRadians);
            ctx.shadowOffsetY = shadowDistance * Math.sin(shadowAngleRadians);
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();

            if (enableOutlineInput.checked) {
                ctx.save();
                ctx.strokeStyle = outlineColorInput.value;
                ctx.lineWidth = parseInt(outlineWidthInput.value);
                ctx.stroke(maskPath);
                ctx.restore();
            }
        } else {
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
        }

        // 3. Draw Pen Tool guides
        if (isPenToolActive && isDrawing && drawingPoints.length > 0) {
            const scale = getPenToolScale();
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = BASE_PEN_LINE_WIDTH * scale;
            ctx.beginPath();
            ctx.moveTo(drawingPoints[0].x, drawingPoints[0].y);
            for (let i = 1; i < drawingPoints.length; i++) {
                ctx.lineTo(drawingPoints[i].x, drawingPoints[i].y);
            }
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            drawingPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, BASE_PEN_POINT_RADIUS * scale, 0, Math.PI * 2);
                ctx.fill();
            });
            if (drawingPoints.length > 0) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(drawingPoints[0].x, drawingPoints[0].y, BASE_PEN_FIRST_POINT_RADIUS * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        // 4. Draw disclaimer
        drawDisclaimer(ctx);
        
        ctx.restore();
    }

    // --- Event Listeners ---
    imageUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                loadImage(event.target.result);
            };
            reader.readAsDataURL(file);
        }
    });
    
    overlayColorInput.addEventListener('input', () => {
        overlayHexValueSpan.textContent = overlayColorInput.value;
        draw();
    });
    overlayOpacityInput.addEventListener('input', () => {
        overlayOpacityValueSpan.textContent = parseFloat(overlayOpacityInput.value).toFixed(2);
        draw();
    });
    overlayPresetBtns.forEach(button => {
        button.addEventListener('click', () => {
            const color = button.dataset.color;
            overlayColorInput.value = color;
            overlayHexValueSpan.textContent = color;
            draw();
        });
    });
    shadowColorInput.addEventListener('input', () => {
        shadowHexValueSpan.textContent = shadowColorInput.value;
        draw();
    });
    shadowOpacityInput.addEventListener('input', () => { 
        shadowOpacityValueSpan.textContent = parseFloat(shadowOpacityInput.value).toFixed(2);
        draw();
    });
    shadowBlurInput.addEventListener('input', () => {
        shadowBlurValueSpan.textContent = `${shadowBlurInput.value}px`;
        draw();
    });
    shadowDistanceInput.addEventListener('input', () => {
        shadowDistanceValueSpan.textContent = `${shadowDistanceInput.value}px`;
        draw();
    });
    shadowAngleInput.addEventListener('input', () => {
        shadowAngleValueSpan.textContent = `${shadowAngleInput.value}°`;
        draw();
    });
    activatePenToolBtn.addEventListener('click', () => {
        isPenToolActive = !isPenToolActive;
        if (isPenToolActive) {
            activatePenToolBtn.textContent = 'Deactivate Pen Tool';
            activatePenToolBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600', 'active:bg-blue-700');
            activatePenToolBtn.classList.add('bg-orange-500', 'hover:bg-orange-600', 'active:bg-orange-700');
            showMessage('Pen tool activated. Click on the image to draw your mask.', 'info');
        } else {
            activatePenToolBtn.textContent = 'Activate Pen Tool';
            activatePenToolBtn.classList.remove('bg-orange-500', 'hover:bg-orange-600', 'active:bg-orange-700');
            activatePenToolBtn.classList.add('bg-blue-500', 'hover:bg-blue-600', 'active:bg-blue-700');
            isDrawing = false;
            showMessage('Pen tool deactivated.', 'info');
        }
        draw();
    });
    clearMaskBtn.addEventListener('click', () => {
        drawingPoints = [];
        maskPath = null;
        isDrawing = false;
        showMessage('Mask cleared!', 'success');
        draw();
    });
    enableOutlineInput.addEventListener('change', draw);
    outlineColorInput.addEventListener('input', () => {
        outlineHexValueSpan.textContent = outlineColorInput.value;
        draw();
    });
    outlineWidthInput.addEventListener('input', () => {
        outlineWidthValueSpan.textContent = `${outlineWidthInput.value}px`;
        draw();
    });

    zoomSlider.addEventListener('input', (e) => {
        zoomLevel = parseFloat(e.target.value);
        zoomValueSpan.textContent = `${Math.round(zoomLevel * 100)}%`;
        if (zoomLevel === 1) {
            panOffset = { x: 0, y: 0 };
        }
        canvas.style.cursor = zoomLevel > 1 ? 'grab' : 'default';
        draw();
    });

    resetViewBtn.addEventListener('click', () => {
        initializeControls();
        draw();
    });

    applyCropBtn.addEventListener('click', () => {
        if (!isImageLoaded) return;

        const sourceX = -panOffset.x;
        const sourceY = -panOffset.y;
        const sourceWidth = canvas.width / zoomLevel;
        const sourceHeight = canvas.height / zoomLevel;

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = sourceWidth;
        tempCanvas.height = sourceHeight;
        const tempCtx = tempCanvas.getContext('2d');

        tempCtx.drawImage(
            originalImage,
            sourceX, sourceY, sourceWidth, sourceHeight,
            0, 0, sourceWidth, sourceHeight
        );
        
        clearMaskBtn.click();
        loadImage(tempCanvas.toDataURL());
        showMessage('Crop applied successfully!', 'success');
    });

    toggleDisclaimerBtn.addEventListener('click', () => {
        isDisclaimerVisible = !isDisclaimerVisible;
        if (isDisclaimerVisible) {
            // Show controls and set default position
            disclaimerControls.classList.remove('hidden');
            toggleDisclaimerBtn.textContent = 'Remove Disclaimer';
            toggleDisclaimerBtn.classList.replace('bg-blue-500', 'bg-red-500');

            // Set initial position to bottom-center of the canvas
            disclaimerProps.x = canvas.width / 2;
            disclaimerProps.y = canvas.height - (disclaimerProps.lineHeight * 3);
        } else {
            // Hide controls
            disclaimerControls.classList.add('hidden');
            toggleDisclaimerBtn.textContent = 'Add Disclaimer';
            toggleDisclaimerBtn.classList.replace('bg-red-500', 'bg-blue-500');
        }
        draw();
    });

    disclaimerFontSizeSlider.addEventListener('input', (e) => {
        const size = parseInt(e.target.value, 10);
        disclaimerProps.fontSize = size;
        disclaimerProps.lineHeight = size * 1.2; // Adjust line height based on font size
        disclaimerFontSizeValue.textContent = `${size}px`;
        draw();
    });

    disclaimerColorInput.addEventListener('input', (e) => {
        disclaimerProps.color = e.target.value;
        disclaimerHexValue.textContent = e.target.value;
        draw();
    });
    
    saveAsJpgBtn.addEventListener('click', () => {
        if (!isImageLoaded) {
            showMessage('Please upload an image first!', 'error');
            return;
        }
        try {
            const imageDataURL = canvas.toDataURL('image/jpeg', 0.9);
            const link = document.createElement('a');
            link.href = imageDataURL;
            link.download = 'graphics_manipulated.jpg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessage('Image saved as JPG!', 'success');
        } catch (error) {
            showMessage('Failed to save image. Error: ' + error.message, 'error');
            console.error('Save image error:', error);
        }
    });

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        // Convert mouse coordinates to the transformed (zoomed/panned) space for hit detection
        const transformedMouseX = (mouseX - panOffset.x) / zoomLevel;
        const transformedMouseY = (mouseY - panOffset.y) / zoomLevel;

        // 1. Handle Disclaimer Dragging
        const bounds = getDisclaimerBounds(ctx);
        if (bounds && transformedMouseX > bounds.x && transformedMouseX < bounds.x + bounds.width &&
            transformedMouseY > bounds.y && transformedMouseY < bounds.y + bounds.height) {
            isDraggingDisclaimer = true;
            canvas.style.cursor = 'move';
            // Record the offset from the text's origin to the click point
            disclaimerDragOffset.x = transformedMouseX - disclaimerProps.x;
            disclaimerDragOffset.y = transformedMouseY - disclaimerProps.y;
            return; // Prioritize disclaimer dragging
        }

        // 2. Handle Panning (if not dragging disclaimer)
        if (zoomLevel > 1 && !isPenToolActive) {
            isPanning = true;
            startPanPoint = { x: mouseX - panOffset.x, y: mouseY - panOffset.y };
            canvas.style.cursor = 'grabbing';
            return;
        }

        // 3. Handle Pen Tool (if not dragging or panning)
        if (isPenToolActive) {
            const transformedX = (mouseX - panOffset.x) / zoomLevel;
            const transformedY = (mouseY - panOffset.y) / zoomLevel;
            
            if (!isDrawing) {
                isDrawing = true;
                drawingPoints.push({ x: transformedX, y: transformedY });
            } else {
                const firstPoint = drawingPoints[0];
                const distance = Math.sqrt(Math.pow(transformedX - firstPoint.x, 2) + Math.pow(transformedY - firstPoint.y, 2));
                const scale = getPenToolScale();
                const closeThreshold = BASE_PEN_CLOSE_THRESHOLD * scale;

                if (distance < closeThreshold) {
                    isDrawing = false;
                    const path = new Path2D();
                    path.moveTo(drawingPoints[0].x, drawingPoints[0].y);
                    for (let i = 1; i < drawingPoints.length; i++) {
                        path.lineTo(drawingPoints[i].x, drawingPoints[i].y);
                    }
                    path.closePath();
                    maskPath = path;
                    drawingPoints = [];
                    showMessage('Mask applied!', 'success');
                } else {
                    drawingPoints.push({ x: transformedX, y: transformedY });
                }
            }
            draw();
        }
    });

    canvas.addEventListener('mousemove', (e) => {
         const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        // 1. Handle Disclaimer Dragging
        if (isDraggingDisclaimer) {
            const transformedMouseX = (mouseX - panOffset.x) / zoomLevel;
            const transformedMouseY = (mouseY - panOffset.y) / zoomLevel;
            disclaimerProps.x = transformedMouseX - disclaimerDragOffset.x;
            disclaimerProps.y = transformedMouseY - disclaimerDragOffset.y;
            draw();
            return;
        }
        
        if (!isPanning) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        panOffset.x = mouseX - startPanPoint.x;
        panOffset.y = mouseY - startPanPoint.y;
        const maxPanX = (canvas.width * zoomLevel - canvas.width);
        const maxPanY = (canvas.height * zoomLevel - canvas.height);
        panOffset.x = Math.max(-maxPanX, Math.min(0, panOffset.x));
        panOffset.y = Math.max(-maxPanY, Math.min(0, panOffset.y));
        draw();
    });

    canvas.addEventListener('mouseup', () => {
        isPanning = false;
        isDraggingDisclaimer = false;
        canvas.style.cursor = zoomLevel > 1 ? 'grab' : 'default';
    });
    
    canvas.addEventListener('mouseleave', () => {
        isPanning = false;
        isDraggingDisclaimer = false;
        canvas.style.cursor = zoomLevel > 1 ? 'grab' : 'default';
    });

    resetAllBtn.addEventListener('click', () => {
        drawingPoints = [];
        maskPath = null;
        isDrawing = false;
        isPenToolActive = false;
        activatePenToolBtn.textContent = 'Activate Pen Tool';
        activatePenToolBtn.classList.remove('bg-orange-500', 'hover:bg-orange-600', 'active:bg-orange-700');
        activatePenToolBtn.classList.add('bg-blue-500', 'hover:bg-blue-600', 'active:bg-blue-700');
        
        loadImage(defaultImageUrl);
        showMessage('All settings reset!', 'success');
    });

    window.addEventListener('resize', draw);

    window.onload = () => {
        initializeControls();
        loadImage(defaultImageUrl);
        canvas.style.width = '100%';
        canvas.style.height = 'auto';
    };
</script>

</body>
</html>
