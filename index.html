<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphics Manipulator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top to allow for scroll if content is long */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .app-container {
            background-color: #ffffff;
            border-radius: 1rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            padding: 1rem; /* Slightly reduced padding for overall fit */
            max-width: 1400px; /* Increased max-width for sidebar */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Reduced gap */
        }
        @media (min-width: 1024px) {
            .app-container {
                flex-direction: row;
                height: 90vh; /* Fixed height for desktop layout */
                align-items: stretch; /* Stretch items to fill height */
            }
        }

        .sidebar {
            width: 100%;
            max-width: 320px; /* Max width for sidebar on desktop */
            background-color: #f8fafc; /* bg-gray-50 */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06); /* subtle inner shadow */
            overflow-y: auto; /* Enable scrolling for many panels */
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            display: flex; /* Ensure flex for internal arrangement */
            flex-direction: column; /* Stack control groups vertically */
            gap: 1.5rem; /* Spacing between control groups */
        }
        @media (min-width: 1024px) {
            .sidebar {
                height: auto; /* Auto height within flex container */
            }
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
        }

        canvas {
            border: 1px solid #e2e8f0; /* border-gray-200 */
            border-radius: 0.5rem; /* rounded-lg */
            background-color: #f8fafc; /* bg-gray-50 */
            width: 100%;
            max-width: 700px; /* Limit canvas width for better control layout */
            height: auto; /* Maintain aspect ratio */
            display: block;
            margin: 0 auto; /* Center canvas */
        }
        
        .control-group {
            background-color: #f8fafc; /* bg-gray-50 */
            padding: 1rem;
            border-radius: 0.75rem; /* rounded-lg */
            border: 1px solid #e2e8f0; /* border-gray-200 */
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #cbd5e1; /* bg-gray-300 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            background: none;
            padding: 0;
            overflow: hidden;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }
        input[type="color"]::-moz-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }
        button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.15), 0 3px 6px -2px rgba(0, 0, 0, 0.08);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
        }
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position the tooltip above the text */
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%; /* At the bottom of the tooltip */
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="app-container bg-white rounded-xl shadow-xl">
        <div class="sidebar">
            <h1 class="text-2xl font-bold text-gray-800 text-center mb-4">Image Editor Tools</h1>

            <!-- Image Upload Panel -->
            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Image Source</h2>
                <input type="file" id="imageUpload" accept="image/*" class="w-full text-gray-700 bg-white border border-gray-300 rounded-md py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>

            <!-- Color Overlay Panel -->
            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Color Overlay (Bottom Layer)</h2>
                <div class="flex items-center gap-4 mb-3">
                    <label for="overlayColor" class="text-gray-600 font-medium">Color:</label>
                    <input type="color" id="overlayColor" value="#3b82f6" class="flex-shrink-0">
                    <span id="overlayHexValue" class="text-gray-700 font-mono text-sm">#3b82f6</span>
                </div>
                <div class="mt-4">
                    <h3 class="text-md font-medium text-gray-600 mb-2">Presets:</h3>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="overlay-preset-btn bg-black text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#000000">Black</button>
                        <button class="overlay-preset-btn bg-yellow-800 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#704214">Sepia</button>
                        <button class="overlay-preset-btn bg-gray-700 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#333333">Dark Gray</button>
                        <button class="overlay-preset-btn bg-white text-gray-800 border border-gray-300 py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#FFFFFF">White</button>
                        <button class="overlay-preset-btn bg-teal-600 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#008080">Teal</button>
                        <button class="overlay-preset-btn bg-purple-600 text-white py-2 px-3 rounded-md text-sm font-medium hover:opacity-80" data-color="#800080">Purple</button>
                    </div>
                </div>
                <div>
                    <label for="overlayOpacity" class="block text-gray-600 font-medium mb-2 mt-4">Opacity:</label>
                    <input type="range" id="overlayOpacity" min="0" max="1" step="0.01" value="0.5" class="w-full">
                    <span id="overlayOpacityValue" class="block text-right text-gray-700 text-sm mt-1">0.50</span>
                </div>
            </div>

            <!-- Pen Tool Panel -->
            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Pen Tool (Top Layer Mask)</h2>
                <div class="flex flex-col sm:flex-row gap-3">
                    <button id="activatePenTool" class="flex-1 bg-blue-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-600 active:bg-blue-700">Activate Pen Tool</button>
                    <button id="clearMask" class="flex-1 bg-red-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-red-600 active:bg-red-700">Clear Mask</button>
                </div>
                <p class="text-sm text-gray-500 mt-3">Click on the canvas to draw points. Click the first point to close the path.</p>
            </div>

            <!-- Drop Shadow Panel -->
            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Drop Shadow (Top Layer)</h2>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <div class="flex items-center gap-2">
                        <label for="shadowColor" class="text-gray-600 font-medium">Color:</label>
                        <input type="color" id="shadowColor" value="#000000" class="flex-shrink-0">
                        <span id="shadowHexValue" class="text-gray-700 font-mono text-sm">#000000</span>
                    </div>
                    <div>
                        <label for="shadowOpacity" class="block text-gray-600 font-medium mb-1">Opacity:</label>
                        <input type="range" id="shadowOpacity" min="0" max="1" step="0.01" value="0.75" class="w-full">
                        <span id="shadowOpacityValue" class="block text-right text-gray-700 text-sm mt-1">0.75</span>
                    </div>
                    <div>
                        <label for="shadowBlur" class="block text-gray-600 font-medium mb-1">Blur:</label>
                        <input type="range" id="shadowBlur" min="0" max="150" step="1" value="10" class="w-full">
                        <span id="shadowBlurValue" class="block text-right text-gray-700 text-sm mt-1">10px</span>
                    </div>
                    <div>
                        <label for="shadowDistance" class="block text-gray-600 font-medium mb-1">Distance:</label>
                        <input type="range" id="shadowDistance" min="0" max="150" step="1" value="5" class="w-full">
                        <span id="shadowDistanceValue" class="block text-right text-gray-700 text-sm mt-1">5px</span>
                    </div>
                    <div class="sm:col-span-2"> <!-- Span two columns for better layout -->
                        <label for="shadowAngle" class="block text-gray-600 font-medium mb-1">Angle:</label>
                        <input type="range" id="shadowAngle" min="0" max="360" step="1" value="45" class="w-full">
                        <span id="shadowAngleValue" class="block text-right text-gray-700 text-sm mt-1">45°</span>
                    </div>
                </div>
            </div>

            <!-- Masked Layer Outline Panel -->
            <div class="control-group">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Masked Layer Outline</h2>
                <div class="flex items-center gap-2 mb-3">
                    <input type="checkbox" id="enableOutline" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <label for="enableOutline" class="text-gray-600 font-medium">Enable Outline</label>
                </div>
                <div class="flex items-center gap-4 mb-3">
                    <label for="outlineColor" class="text-gray-600 font-medium">Color:</label>
                    <input type="color" id="outlineColor" value="#ffffff" class="flex-shrink-0">
                    <span id="outlineHexValue" class="text-gray-700 font-mono text-sm">#ffffff</span>
                </div>
                <div>
                    <label for="outlineWidth" class="block text-gray-600 font-medium mb-2">Width:</label>
                    <input type="range" id="outlineWidth" min="0" max="100" step="1" value="2" class="w-full">
                    <span id="outlineWidthValue" class="block text-right text-gray-700 text-sm mt-1">2px</span>
                </div>
            </div>

            <!-- Save and Reset Buttons -->
            <div class="flex flex-col gap-3 mt-4">
                <button id="saveAsJpg" class="bg-green-500 text-white py-3 px-6 rounded-lg font-semibold hover:bg-green-600 active:bg-green-700 w-full">Save as JPG</button>
                <button id="resetAll" class="bg-gray-200 text-gray-800 py-3 px-6 rounded-lg font-semibold hover:bg-gray-300 active:bg-gray-400 w-full">Reset All</button>
            </div>
        </div>

        <div class="main-content">
            <canvas id="imageCanvas" class="w-full h-auto rounded-lg shadow-md"></canvas>
            <div id="messageBox" class="mt-4 p-3 bg-blue-100 text-blue-800 rounded-md hidden"></div>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const messageBox = document.getElementById('messageBox');

    const imageUpload = document.getElementById('imageUpload');
    const overlayColorInput = document.getElementById('overlayColor');
    const overlayHexValueSpan = document.getElementById('overlayHexValue');
    const overlayOpacityInput = document.getElementById('overlayOpacity');
    const overlayOpacityValueSpan = document.getElementById('overlayOpacityValue');

    const overlayPresetBtns = document.querySelectorAll('.overlay-preset-btn');

    const activatePenToolBtn = document.getElementById('activatePenTool');
    const clearMaskBtn = document.getElementById('clearMask');

    const shadowColorInput = document.getElementById('shadowColor');
    const shadowHexValueSpan = document.getElementById('shadowHexValue');
    const shadowOpacityInput = document.getElementById('shadowOpacity'); 
    const shadowOpacityValueSpan = document.getElementById('shadowOpacityValue');
    const shadowBlurInput = document.getElementById('shadowBlur');
    const shadowBlurValueSpan = document.getElementById('shadowBlurValue');
    const shadowDistanceInput = document.getElementById('shadowDistance');
    const shadowDistanceValueSpan = document.getElementById('shadowDistanceValue');
    const shadowAngleInput = document.getElementById('shadowAngle');
    const shadowAngleValueSpan = document.getElementById('shadowAngleValue');

    const enableOutlineInput = document.getElementById('enableOutline');
    const outlineColorInput = document.getElementById('outlineColor');
    const outlineHexValueSpan = document.getElementById('outlineHexValue');
    const outlineWidthInput = document.getElementById('outlineWidth');
    const outlineWidthValueSpan = document.getElementById('outlineWidthValue');

    const saveAsJpgBtn = document.getElementById('saveAsJpg');
    const resetAllBtn = document.getElementById('resetAll');

    let originalImage = new Image();
    let isImageLoaded = false;

    // Pen tool state
    let isPenToolActive = false;
    let drawingPoints = [];
    let isDrawing = false;
    let maskPath = null; 

    // Default values
    const defaultOverlayColor = '#3b82f6';
    const defaultOverlayOpacity = 0.5;
    const defaultShadowColor = '#000000';
    const defaultShadowOpacity = 0.75; 
    const defaultShadowBlur = 10;
    const defaultShadowDistance = 5;
    const defaultShadowAngle = 45;
    const defaultEnableOutline = false;
    const defaultOutlineColor = '#ffffff';
    const defaultOutlineWidth = 2;

    const defaultImageUrl = 'https://placehold.co/700x500/A0B0C0/FFFFFF?text=Upload+Image'; 

    // ✨ NEW: Define base sizes for the pen tool for scaling
    const BASE_PEN_LINE_WIDTH = 3;       // Base line thickness
    const BASE_PEN_POINT_RADIUS = 6;     // Base radius for drawing points
    const BASE_PEN_FIRST_POINT_RADIUS = 8; // Base radius for the starting point
    const BASE_PEN_CLOSE_THRESHOLD = 12; // Base click distance to close the path

    // Helper function to convert hex to RGBA
    function hexToRgba(hex, alpha) {
        let r = 0, g = 0, b = 0;
        if (hex.length === 4) {
            r = parseInt(hex[1] + hex[1], 16);
            g = parseInt(hex[2] + hex[2], 16);
            b = parseInt(hex[3] + hex[3], 16);
        } else if (hex.length === 7) {
            r = parseInt(hex.substring(1, 3), 16);
            g = parseInt(hex.substring(3, 5), 16);
            b = parseInt(hex.substring(5, 7), 16);
        }
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // ✨ NEW: Helper function to calculate the scaling factor for the pen tool
    function getPenToolScale() {
        const referenceWidth = 700; // The width of the default placeholder image
        if (!isImageLoaded || !canvas.width) {
            return 1; // Return a default scale of 1 if there's no image
        }
        // Calculate scale based on the current image's width relative to the reference
        return canvas.width / referenceWidth;
    }

    // Initialize controls with default values
    function initializeControls() {
        overlayColorInput.value = defaultOverlayColor;
        overlayHexValueSpan.textContent = defaultOverlayColor;
        overlayOpacityInput.value = defaultOverlayOpacity;
        overlayOpacityValueSpan.textContent = defaultOverlayOpacity.toFixed(2);

        shadowColorInput.value = defaultShadowColor;
        shadowHexValueSpan.textContent = defaultShadowColor;
        shadowOpacityInput.value = defaultShadowOpacity; 
        shadowOpacityValueSpan.textContent = defaultShadowOpacity.toFixed(2); 
        shadowBlurInput.value = defaultShadowBlur;
        shadowBlurValueSpan.textContent = `${defaultShadowBlur}px`;
        shadowDistanceInput.value = defaultShadowDistance;
        shadowDistanceValueSpan.textContent = `${defaultShadowDistance}px`;
        shadowAngleInput.value = defaultShadowAngle;
        shadowAngleValueSpan.textContent = `${defaultShadowAngle}°`;

        enableOutlineInput.checked = defaultEnableOutline;
        outlineColorInput.value = defaultOutlineColor;
        outlineHexValueSpan.textContent = defaultOutlineColor;
        outlineWidthInput.value = defaultOutlineWidth;
        outlineWidthValueSpan.textContent = `${defaultOutlineWidth}px`;
    }

    // Function to display messages to the user
    function showMessage(message, type = 'info') {
        messageBox.textContent = message;
        messageBox.classList.remove('hidden', 'bg-blue-100', 'text-blue-800', 'bg-red-100', 'text-red-800', 'bg-green-100', 'text-green-800');
        if (type === 'info') {
            messageBox.classList.add('bg-blue-100', 'text-blue-800');
        } else if (type === 'error') {
            messageBox.classList.add('bg-red-100', 'text-red-800');
        } else if (type === 'success') {
            messageBox.classList.add('bg-green-100', 'text-green-800');
        }
        setTimeout(() => {
            messageBox.classList.add('hidden');
        }, 3000); 
    }

    // Function to load the initial image
    function loadImage(src) {
        originalImage.onload = () => {
            isImageLoaded = true;
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            draw();
            showMessage('Image loaded successfully!', 'success');
        };
        originalImage.onerror = () => {
            isImageLoaded = false;
            showMessage('Failed to load image. Please try another one.', 'error');
            originalImage.src = defaultImageUrl;
        };
        originalImage.src = src;
    }

    // Main drawing function
    function draw() {
        if (!isImageLoaded) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#666';
            ctx.font = '20px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Upload an image to start', canvas.width / 2, canvas.height / 2);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Bottom Layer with Color Overlay
        ctx.save();
        ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

        const overlayColor = overlayColorInput.value;
        const overlayOpacity = parseFloat(overlayOpacityInput.value);

        ctx.fillStyle = overlayColor;
        ctx.globalAlpha = overlayOpacity;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        // 2. Draw Top Layer with Mask and Drop Shadow
        if (maskPath) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.save();
            tempCtx.clip(maskPath);
            tempCtx.drawImage(originalImage, 0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.restore();

            ctx.save();
            const shadowDistance = parseInt(shadowDistanceInput.value);
            const shadowAngleDegrees = parseInt(shadowAngleInput.value);
            const shadowAngleRadians = (shadowAngleDegrees - 180) * Math.PI / 180;
            const shadowOpacity = parseFloat(shadowOpacityInput.value); 

            ctx.shadowColor = hexToRgba(shadowColorInput.value, shadowOpacity);
            ctx.shadowBlur = parseInt(shadowBlurInput.value);
            ctx.shadowOffsetX = shadowDistance * Math.cos(shadowAngleRadians);
            ctx.shadowOffsetY = shadowDistance * Math.sin(shadowAngleRadians);
            
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();

            // 3. Draw Outline for Masked Layer (if enabled)
            if (enableOutlineInput.checked) {
                ctx.save();
                ctx.strokeStyle = outlineColorInput.value;
                ctx.lineWidth = parseInt(outlineWidthInput.value);
                ctx.stroke(maskPath);
                ctx.restore();
            }

        } else {
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
        }

        // ✨ MODIFIED: If pen tool is active, draw the path with scaled sizes
        if (isPenToolActive && isDrawing && drawingPoints.length > 0) {
            const scale = getPenToolScale(); // Get the current scale factor

            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = BASE_PEN_LINE_WIDTH * scale; // Apply scaling
            ctx.beginPath();
            ctx.moveTo(drawingPoints[0].x, drawingPoints[0].y);
            for (let i = 1; i < drawingPoints.length; i++) {
                ctx.lineTo(drawingPoints[i].x, drawingPoints[i].y);
            }
            ctx.stroke();

            // Draw scaled points
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            drawingPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, BASE_PEN_POINT_RADIUS * scale, 0, Math.PI * 2); // Apply scaling
                ctx.fill();
            });

            // Draw a scaled, larger point for the start of the path
            if (drawingPoints.length > 0) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(drawingPoints[0].x, drawingPoints[0].y, BASE_PEN_FIRST_POINT_RADIUS * scale, 0, Math.PI * 2); // Apply scaling
                ctx.fill();
            }
        }
    }

    // Event Listeners for Controls

    imageUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                loadImage(event.target.result);
            };
            reader.readAsDataURL(file);
        }
    });

    overlayColorInput.addEventListener('input', () => {
        overlayHexValueSpan.textContent = overlayColorInput.value;
        draw();
    });
    overlayOpacityInput.addEventListener('input', () => {
        overlayOpacityValueSpan.textContent = parseFloat(overlayOpacityInput.value).toFixed(2);
        draw();
    });

    overlayPresetBtns.forEach(button => {
        button.addEventListener('click', () => {
            const color = button.dataset.color;
            overlayColorInput.value = color;
            overlayHexValueSpan.textContent = color;
            draw();
        });
    });

    shadowColorInput.addEventListener('input', () => {
        shadowHexValueSpan.textContent = shadowColorInput.value;
        draw();
    });
    shadowOpacityInput.addEventListener('input', () => { 
        shadowOpacityValueSpan.textContent = parseFloat(shadowOpacityInput.value).toFixed(2);
        draw();
    });
    shadowBlurInput.addEventListener('input', () => {
        shadowBlurValueSpan.textContent = `${shadowBlurInput.value}px`;
        draw();
    });
    shadowDistanceInput.addEventListener('input', () => {
        shadowDistanceValueSpan.textContent = `${shadowDistanceInput.value}px`;
        draw();
    });
    shadowAngleInput.addEventListener('input', () => {
        shadowAngleValueSpan.textContent = `${shadowAngleInput.value}°`;
        draw();
    });

    activatePenToolBtn.addEventListener('click', () => {
        isPenToolActive = !isPenToolActive;
        if (isPenToolActive) {
            activatePenToolBtn.textContent = 'Deactivate Pen Tool';
            activatePenToolBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600', 'active:bg-blue-700');
            activatePenToolBtn.classList.add('bg-orange-500', 'hover:bg-orange-600', 'active:bg-orange-700');
            showMessage('Pen tool activated. Click on the image to draw your mask.', 'info');
        } else {
            activatePenToolBtn.textContent = 'Activate Pen Tool';
            activatePenToolBtn.classList.remove('bg-orange-500', 'hover:bg-orange-600', 'active:bg-orange-700');
            activatePenToolBtn.classList.add('bg-blue-500', 'hover:bg-blue-600', 'active:bg-blue-700');
            isDrawing = false;
            showMessage('Pen tool deactivated.', 'info');
        }
        draw();
    });

    clearMaskBtn.addEventListener('click', () => {
        drawingPoints = [];
        maskPath = null;
        isDrawing = false;
        showMessage('Mask cleared!', 'success');
        draw();
    });

    enableOutlineInput.addEventListener('change', draw);
    outlineColorInput.addEventListener('input', () => {
        outlineHexValueSpan.textContent = outlineColorInput.value;
        draw();
    });
    outlineWidthInput.addEventListener('input', () => {
        outlineWidthValueSpan.textContent = `${outlineWidthInput.value}px`;
        draw();
    });

    saveAsJpgBtn.addEventListener('click', () => {
        if (!isImageLoaded) {
            showMessage('Please upload an image first!', 'error');
            return;
        }
        try {
            const imageDataURL = canvas.toDataURL('image/jpeg', 0.9); 
            const link = document.createElement('a');
            link.href = imageDataURL;
            link.download = 'graphics_manipulated.jpg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessage('Image saved as JPG!', 'success');
        } catch (error) {
            showMessage('Failed to save image. Error: ' + error.message, 'error');
            console.error('Save image error:', error);
        }
    });

    resetAllBtn.addEventListener('click', () => {
        initializeControls();
        drawingPoints = [];
        maskPath = null;
        isDrawing = false;
        isPenToolActive = false;
        activatePenToolBtn.textContent = 'Activate Pen Tool';
        activatePenToolBtn.classList.remove('bg-orange-500', 'hover:bg-orange-600', 'active:bg-orange-700');
        activatePenToolBtn.classList.add('bg-blue-500', 'hover:bg-blue-600', 'active:bg-blue-700');
        loadImage(defaultImageUrl);
        showMessage('All settings reset!', 'success');
    });

    canvas.addEventListener('mousedown', (e) => {
        if (!isPenToolActive || !isImageLoaded) return;

        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);

        if (!isDrawing && drawingPoints.length === 0) {
            isDrawing = true;
            drawingPoints.push({ x, y });
        } else if (isDrawing) {
            const firstPoint = drawingPoints[0];
            const distance = Math.sqrt(Math.pow(x - firstPoint.x, 2) + Math.pow(y - firstPoint.y, 2));

            // ✨ MODIFIED: Use the scaled threshold for closing the path
            const scale = getPenToolScale();
            const closeThreshold = BASE_PEN_CLOSE_THRESHOLD * scale;

            if (distance < closeThreshold) { // Use scaled value
                isDrawing = false;
                const path = new Path2D();
                path.moveTo(drawingPoints[0].x, drawingPoints[0].y);
                for (let i = 1; i < drawingPoints.length; i++) {
                    path.lineTo(drawingPoints[i].x, drawingPoints[i].y);
                }
                path.closePath();
                maskPath = path;
                drawingPoints = [];
                showMessage('Mask applied!', 'success');
            } else {
                drawingPoints.push({ x, y });
            }
        }
        draw();
    });

    window.addEventListener('resize', () => {
        // Redraw on resize, which helps if the layout changes responsively
        draw();
    });

    window.onload = () => {
        initializeControls();
        loadImage(defaultImageUrl);
        // Ensure canvas display size fits the container
        canvas.style.width = '100%';
        canvas.style.height = 'auto';
    };
</script>
</body>
</html>
